# guick : a Graphical User Interface for CLI using Click or Typer

![PyPI - Version](https://img.shields.io/pypi/v/guick?label=pypi%20package&color=%252334D058) ![GitHub License](https://img.shields.io/github/license/FabeG/guick) [![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black) [![.github/workflows/test.yml](https://github.com/FabeG/guick/actions/workflows/test.yml/badge.svg)](https://github.com/FabeG/guick/actions/workflows/test.yml) [![codecov](https://codecov.io/github/fabeg/guick/branch/main/graph/badge.svg?token=4DV1Z3Q0QK)](https://codecov.io/github/fabeg/guick)


## Introduction

guick (Graphical User Interface Creation Kit) can transform your command line interface
(CLI) based on [Click](https://click.palletsprojects.com/en/stable/) or [Typer](https://typer.tiangolo.com/) into a graphical user interface (GUI) with just a few lines of code.

guick is built on top of [Click](https://click.palletsprojects.com/en/stable/) and [wxPython](https://www.wxpython.org/).


## Installation

### On Windows / MacOS

Since wxpython provides precompiled wheels for Windows and MacOS, you can simply install guick using pip:

```python

pip install guick

```

### On Linux


```python

pip install guick[all]

```

> [!NOTE]
> On Linux, no precompiled wheels are provided for wxpython on pypi and installing wxpython can be tricky.
> You can refer to the [troubleshooting section of the installation documentation](https://guick.readthedocs.io/en/latest/installation.html#troubleshooting) if you need help.

## A simple example

### If you come from ``Click``

Just add ``cls=CommandGui`` to your ``click.command``, and guick will transform your Command Line Interface into a Graphical User Interface:

Starting with the following very simple Click CLI application (file ``click_first_basic_example.py``):

```python
import click


@click.command()
@click.option("--name")
def first_basic_example(name):
    print(f"Hello {name}!")


if __name__ == "__main__":
    first_basic_example()
```

that you would run from the command line like this:

```console
$ python click_first_basic_example.py --name "John Doe"

Hello John Doe!
```

By just adding ``cls=CommandGui`` to your ``click.command``:

```diff
import click
+import guick


+@click.command(cls=guick.CommandGui)
@click.option("--name")
def first_basic_example(name):
    print(f"Hello {name}!")


if __name__ == "__main__":
    first_basic_example()
```

and run the application **with no arguments**:

```console
$ python click_first_basic_example.py
```

You will get the following GUI that will include:
- an ``Help`` menu automatically created using the ``--help`` generated by ``Click``
- a ``Log`` panel to display the standard output of the application
- and still, if you feel nostalgic, you can run the CLI as before, as long as you provide any parameter to the command line.

![First Click example](/docs/images/click_basic_first_example.gif)


### If you come from ``Typer``

Starting with the following very simple ``Typer`` CLI application (file
``typer_first_basic_example.py``):

```python
import typer

app = typer.Typer()


@app.command()
def first_basic_example(name: str):
    print(f"Hello {name}!")


if __name__ == "__main__":
    app()
```

that you would run from the command line like this:

```console
$ python typer_first_basic_example.py --name "John Doe"

Hello John Doe!

```

By just adding ``cls=TyperCommand`` to your ``app.command``:

```diff
+import guick
import typer

app = typer.Typer()


+@app.command(cls=guick.TyperCommandGui)
def first_basic_example(name: str):
    print(f"Hello {name}!")


if __name__ == "__main__":
    app()
```

and run the application **with no arguments**:

```console

$ python typer_first_basic_example.py

```

You will get the following GUI that will include:
- The title of the window taken from the function name
- an ``Help`` menu automatically created using the ``--help`` generated by ``TYper``
- a panel gathering **Required** and **Optional** parameters
- a ``Log`` panel to display the standard output of the application
- and still, if you feel nostalgic, you can run the CLI as before, as long as you provide any parameter to the command line.

![First Typer example](/docs/images/typer_basic_first_example.gif)

## An example with subcommands

In the following example (taken from the excellent [Typer documentation](https://typer.tiangolo.com/#example-upgrade)), we will consider a Typer app with 2 subcommands.

In order to generate the GUI, we only have to add 2 lines of code:


```diff
+import guick
import typer

+app = typer.Typer(cls=guick.TyperGroupGui)


@app.command()
def hello(name: str):
    print(f"Hello {name}")


@app.command()
def goodbye(name: str, formal: bool = False):
    if formal:
        print(f"Goodbye Ms. {name}. Have a good day.")
    else:
        print(f"Bye {name}!")


if __name__ == "__main__":
    app()
```

And by running the application with **no arguments**:

```console
$ python typer_subcommands_example.py
```

The following GUI will be displayed:

![Typer subcommand example](/docs/images/typer_subcommands_example.gif)

## Support most of standard ``Click`` / ``Typer`` types

- **bool** options are rendered as **CheckBox**,
- **click.Choice** / Enum options are rendered as **ComboBox**,
- **click.Path** / **click.File** options are rendered as **FileDialog** (with **Drag & Drop support**)
- **click.types.IntRange** options are rendered as **Slider**
- **click.DateTime** options are rendered using a **DateTimePicker**
- text entries for **string** options with ``hide_input=True`` are hidden (useful for **password**)
- all other option types (including custom types) are rendred as normal text entry

> [!NOTE]
> - There is only a basic support for the following kind of options:
>   - multi value options (using ``nargs``)
>   - **tuples** as option types
>   - Multiple options (using ``multiple=True``)

## With validation included

Taking advantage of ``Click`` validation rules, if an option doesn't pass the
validation, a red text will be shown, explaining the error.


```python
from typing import Annotated

import guick
import typer

app = typer.Typer()


@app.command(cls=guick.TyperCommandGui)
def main(
    id: Annotated[int, typer.Argument(min=0, max=1000)],
    age: Annotated[int, typer.Option(min=18)] = 20,
    score: Annotated[float, typer.Option(max=100)] = 0,
):
    print(f"ID is {id}")
    print(f"--age is {age}")
    print(f"--score is {score}")


if __name__ == "__main__":
    app()
```

![First Click example](/docs/images/parameter_validation.gif)

## Using default values if any

Take into account **default values** for options if they are defined

## History

Keeping track of the last values of options: options fields are prefilled using the
option values from the previous run

## Separate required / optional options

The **required** and **optional** options are seperated in the GUI to clearly see what
are the mandatory options



## Standard output is redirected to the GUI

## ...with basic support of colorized Terminal log

## Automatically creates an ``Help`` menu

With hyperlink if URL is detected, enabling to go directly to the html documentation pages

## Automatically handles ``--version`` option

By adding a ``About`` section in the ``Help`` menu

## Support **group** options using notebook
